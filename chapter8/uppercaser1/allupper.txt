SECTION .BSS
	BUFF RESB 1

SECTION .DATA

SECTION .TEXT
	GLOBAL _START

_START:
	NOP            ; THIS NO-OP KEEPS THE DEBUGGER HAPPY

READ:
    MOV RAX,0   	; SPECIFY SYS_READ CALL
	MOV RDI,0      ; SPECIFY FILE DESCRIPTOR 0: STANDARD INPUT
	MOV RSI,BUFF   ; PASS OFFSET OF THE BUFFER TO READ TO
	MOV RDX,1      ; TELL SYS_READ TO READ ONE CHAR FROM STDIN
	SYSCALL        ; CALL SYS_READ

	CMP EAX,0	; LOOK AT SYS_READ'S RETURN VALUE IN EAX
	JE EXIT		; JUMP IF EQUAL TO 0 (0 MEANS EOF) TO EXIT
			; OR FALL THROUGH TO TEST FOR LOWERCASE
	CMP BYTE [BUFF],61H  ; TEST INPUT CHAR AGAINST LOWERCASE 'A'
	JB WRITE	; IF BELOW 'A' IN ASCII CHART, NOT LOWERCASE
	CMP BYTE [BUFF],7AH  ; TEST INPUT CHAR AGAINST LOWERCASE 'Z'
	JA WRITE	; IF ABOVE 'Z' IN ASCII CHART, NOT LOWERCASE
			; AT THIS POINT, WE HAVE A LOWERCASE CHARACTER
	SUB BYTE [BUFF],20H  ; SUBTRACT 20H FROM LOWERCASE TO GIVE UPPERCASE...
			; ...AND THEN WRITE OUT THE CHAR TO STDOUT
WRITE:
    MOV RAX,1	; SPECIFY SYS_WRITE CALL
	MOV RDI,1	; SPECIFY FILE DESCRIPTOR 1: STANDARD OUTPUT
	MOV RSI,BUFF	; PASS ADDRESS OF THE CHARACTER TO WRITE
	MOV RDX,1	; PASS NUMBER OF CHARS TO WRITE
	SYSCALL		; CALL SYS_WRITE...
	JMP READ	; ...THEN GO TO THE BEGINNING TO GET ANOTHER CHARACTER

EXIT:
    MOV RAX,60	; CODE FOR EXIT SYSCALL
	MOV RDI,0	; RETURN A CODE OF ZERO TO LINUX
	SYSCALL		; MAKE KERNEL CALL TO EXIT PROGRAM
